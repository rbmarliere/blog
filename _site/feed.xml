<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://marliere.net/~ricardo/feed.xml" rel="self" type="application/atom+xml" /><link href="https://marliere.net/~ricardo/" rel="alternate" type="text/html" /><updated>2023-10-12T10:25:31-03:00</updated><id>https://marliere.net/~ricardo/feed.xml</id><title type="html">Ricardo B. Marliere</title><subtitle>Yet another blog</subtitle><entry><title type="html">Booting a minimal upstream kernel in a Raspberry Pi 3</title><link href="https://marliere.net/~ricardo/2023/10/12/raspberrypi.html" rel="alternate" type="text/html" title="Booting a minimal upstream kernel in a Raspberry Pi 3" /><published>2023-10-12T10:05:00-03:00</published><updated>2023-10-12T10:05:00-03:00</updated><id>https://marliere.net/~ricardo/2023/10/12/raspberrypi</id><content type="html" xml:base="https://marliere.net/~ricardo/2023/10/12/raspberrypi.html"><![CDATA[<p>In this post, I will go through the steps for building and booting a <a href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/">linux-next</a>
kernel on that board you have gathering dust somewhere.</p>

<p><img src="/~ricardo/assets/rpi.png" alt="raspberry" /></p>

<p>— <strong>DISCLAIMER</strong>: <em>The contents of this post may be severely outdated by the time you read
them.</em></p>

<p>Back in my <a href="https://www.funtoo.org">Funtoo</a> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> days, I wrote a nasty <a href="https://github.com/rbmarliere/sysroot">script</a> to organize the
steps required to have a functioning cross-compilation toolchain in order to build the
<a href="https://github.com/raspberrypi/linux">vendor</a> kernel. It had all sort of weird things that I wanted to learn,
such as embedding a dropbear ssh server in the initramfs and filesystem encryption. This
time, I wanted to try a different approach: what is the minimum possible setup I can
come up with to properly boot a root filesystem on the Pi?</p>

<p>If you followed along my <a href="/~ricardo/2023/10/08/better-workflow.html">last post</a>, you noticed that I chose to
configure a crash kernel to use with Kdump/Kexec from zero (<em>make allnoconfig</em>). Though
time consuming and a bit frustrating at times, its something that teached me
tremendously. The demanding trial and error process actually made me assimilate many key
kernel configuration symbols and how they work together, it was a great exercise.</p>

<p>This time, I knew that it wouldn’t be as simple as it were for a x86_64 virtual machine
that emulates ancient hardware. With the Pi, I wanted to run an arm64 recent upstream
kernel with the minimal possible amount of firmware aswell. Though there are many
great <a href="https://www.raspberrypi.com/documentation/computers/linux_kernel.html">resources</a> <a href="https://elinux.org/RPi_Upstream_Kernel_Compilation">available</a>, I was on my own. Here is what I came up with.</p>

<h2 id="debian-root-filesystem">Debian Root Filesystem</h2>

<p>First things first, we need a system to boot into. For that, I chose
<a href="https://tracker.debian.org/pkg/debootstrap">debootstrap</a> to create a full Debian system for the arm64 architecture.
This way you can chroot into the filesystem and act freely before properly burning an
image into an sd card. This is the process (all the variables in this post are
illustrative):</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nv">ROOTFS_PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/debian/arm64"</span>

apt <span class="nb">install </span>debootstrap qemu-user-static binfmt-support qemu-system-arm

debootstrap <span class="nt">--arch</span> arm64 <span class="se">\</span>
            <span class="nt">--components</span><span class="o">=</span>main,contrib,non-free,non-free-firmware <span class="se">\</span>
            <span class="nt">--foreign</span> <span class="se">\</span>
            trixie <span class="se">\</span>
            <span class="nv">$ROOTFS_PATH</span>

<span class="nb">chroot</span> <span class="nv">$ROOTFS_PATH</span> bash <span class="nt">-c</span> <span class="s2">"/debootstrap/debootstrap --second-stage"</span></code></pre></figure>

<ul>
  <li>qemu-user-static is <a href="https://wiki.debian.org/EmDebian/CrossDebootstrap#QEMU.2Fdebootstrap_approach">needed</a> to actually be able to chroot into the root directory and
execute the arm64 programs therein from a foreign host (in my case, x86_64).</li>
  <li>“trixie” is the current <a href="https://www.debian.org/releases/">testing</a> distribution.</li>
  <li>Notice the <em>--foreign</em> argument to debootstrap. This is needed because you’re building a
root that is of an architecture that is different than your host’s. Because of that, an
extra step is <a href="https://sources.debian.org/src/debootstrap/1.0.132/debootstrap.8/#L126">required</a> (the second stage).</li>
</ul>

<p>Now, add the <em>/etc/fstab</em> file while at it:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nb">echo</span> <span class="s2">"/dev/mmcblk0p2 / ext4 defaults,noatime 0 1"</span> <span class="o">&gt;</span> <span class="nv">$ROOTFS_PATH</span>/etc/fstab</code></pre></figure>

<h2 id="kernel-build">Kernel build</h2>

<p>You could build your kernel from inside the aarch64 <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> root, but that would have a hit on
performance and also increase the size of the root with all the required packages to
make it happen. We wanna keep things nice and clean. There are many <a href="https://kernel.org/pub/tools/crosstool/">options</a>
of toolchains out there that you can use for cross-compilation. This is the Debian way:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

apt <span class="nb">install </span>gcc-aarch64-linux-gnu</code></pre></figure>

<p>If you haven’t yet, this is the time you actually pull the Linux sources. If you’re not
familiar with the <a href="https://www.kernel.org/doc/man-pages/linux-next.html">linux-next</a> tree, that’s where the kernel developers merge
their changes targeting the next <a href="https://www.kernel.org/doc/html/latest/process/2.Process.html">merge window</a>. Its goal is to be a reliable
preview of what the next version will look like, thus it conveniently anticipate many
common problems such as build errors and commit conflicts. Go ahead and setup your
sources, with something like this – I can’t recommend <a href="https://git-scm.com/docs/git-worktree">git-worktrees</a>
highly enough:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># create your local work directory</span>
<span class="nv">LINUX_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/linux"</span>
<span class="nb">mkdir</span> <span class="nv">$LINUX_DIR</span>
<span class="nb">cd</span> <span class="nv">$LINUX_DIR</span>

<span class="c"># clone a bare repository</span>
git clone <span class="nt">--bare</span> <span class="nt">-o</span> linus git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
<span class="nb">cd </span>linux.git

<span class="c"># add linux-next remote</span>
git remote add next git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git

<span class="c"># update all remotes</span>
git remote update

<span class="c"># add a worktree for the kernel you want to hack</span>
git worktree add <span class="nt">--checkout</span> ../next-arm64 next-20231011
<span class="nb">cd</span> ../next-arm64</code></pre></figure>

<p>Now let’s export some variables. When you <a href="https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins">export</a> a variable, it is passed down to
the processes that you call, so <code class="language-plaintext highlighter-rouge">export ARCH=arm64; make</code> has the same effect as of
<code class="language-plaintext highlighter-rouge">ARCH=arm64 make</code>. This is useful if you’re constantly running the same commands over
and over again and don’t want a bloated sea of characters in your prompt.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># the target architecture</span>
<span class="nb">export </span><span class="nv">ARCH</span><span class="o">=</span>arm64
<span class="c"># fixed part of the binutils filenames from gcc-aarch64-linux-gnu package</span>
<span class="nb">export </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>/usr/bin/aarch64-linux-gnu-
<span class="c"># where the kernel will be installed to</span>
<span class="nb">export </span><span class="nv">INSTALL_PATH</span><span class="o">=</span><span class="nv">$ROOTFS_PATH</span>/boot
<span class="c"># where the modules will be installed to</span>
<span class="nb">export </span><span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span><span class="nv">$ROOTFS_PATH</span>
<span class="c"># where the device tree bindings of the Pi will be installed to</span>
<span class="nb">export </span><span class="nv">INSTALL_DTBS_PATH</span><span class="o">=</span><span class="nv">$ROOTFS_PATH</span>/boot</code></pre></figure>

<p>All of these are properly documented <a href="https://www.kernel.org/doc/html/latest/kbuild/kbuild.html">here</a>, apart from the usual “<em>make help</em>”.
There’s also some precious tips in the kernel <a href="https://www.kernel.org/doc/html/latest/kbuild/kconfig.html">documentation</a>, I wasn’t aware
of the scripts/diffconfig tool before, which is very useful for messing around with
configuration files. Also, inspecting old files with “<em>make listnewconfig</em>” can be
specially useful when analyzing vendor defaults.</p>

<p>Now comes the fun part, configuring the kernel:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

make allnoconfig
<span class="c"># from `make help`:</span>
<span class="c"># allnoconfig     - New config where all options are answered with no</span>

make menuconfig
<span class="c"># TIP: when you search for a string using '/' character, the list provided</span>
<span class="c"># have numbers attached to them, which you can use to quickly jump to its</span>
<span class="c"># entry in the menu; you can also use '?' character for help.</span></code></pre></figure>

<p>For starters, you need to enable support for the <a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Model_comparison">chip</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ARCH_BCM             Broadcom System-on-Chip systems
ARCH_BCM2835         BCM2837 and BCM2711 SoCs (Raspberry Pi 3 and 4)
</code></pre></div></div>

<p>Then, you might wanna see some output on the screen – through the HDMI port in my case:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DRM                  Direct Rendering Infrastructure, introduced in XFree86 4.0
DRM_V3D              Broadcom V3D GPU
DRM_FBDEV_EMULATION  Legacy fbdev emulation for DRM
FB                   Frame buffer device abstraction layer
FB_SIMPLE            Support for a simple framebuffer
</code></pre></div></div>

<p>Later, we will burn an image into a sd card and use it for booting, so we need support
for it and also the EXT4 filesystem which will be used in the root partition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MMC                  MMC/SD/SDIO I/O support
MMC_BCM2835          MultiMediaCard controller driver for the BCM2835
EXT4_FS              Extended Filesystem 4th generation
</code></pre></div></div>

<p>After successfully recognizing the disk and the root partition, the kernel will call the
<em>/sbin/init</em>, which in this case is a link to <em>/lib/systemd/systemd</em> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. For that, there
are many requirements:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BINFMT_ELF           Support for Executable and Linkable Format (ELF)
DEVTMPFS             Early ramfs instance at bootup for /dev
TMPFS                In-memory filesystem support
CGROUPS              Process grouping isolation
INOTIFY_USER         File monitoring interface for userspace
NET                  Networking support
UNIX                 Unix domain sockets
</code></pre></div></div>

<p>At this point you will land on a login prompt, but there will be no way of doing
anything because you haven’t added support for input yet. Let’s say you want to use a
simple USB keyboard, you first need to enable the features that permit the kernel to
power and communicate with devices:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MAILBOX              On-chip processors communication framework
BCM2835_MBOX         Mailbox for the BCM2835 SoC
RASPBERRYPI_FIRMWARE Support communication with the Raspberry Pi firmware
RASPBERRYPI_POWER    Raspberry Pi power domain support
PM                   Device Power Management core functionality
</code></pre></div></div>

<p>Then you can actually add the USB and HID buses:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>USB_SUPPORT          Core Universal Serial Bus (USB) support
USB                  Enable host-side USB support
USB_DWC2             Raspberry Pi 3 DWC2 USB Controller
HID_SUPPORT          Human interface devices support
</code></pre></div></div>

<p>In my case, this is the driver I needed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INPUT_KEYBOARD       Enables keyboard drivers selection submenu
KEYBOARD_ATKBD       Standard AT/PS2 keyboard
</code></pre></div></div>

<p>That’s it, should be enough to have a working root. Build and install the kernel now,
making sure you have installed its <a href="https://www.kernel.org/doc/html/latest/process/changes.html">requirements</a>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
<span class="c"># make modules_install</span>
make dtbs_install
make <span class="nb">install</span></code></pre></figure>

<h2 id="boot-loader">Boot Loader</h2>

<p>To boot from a sd card, you need a vfat partition at the start of the disk containing
the firmware files. This is gonna be the <em>/boot</em>, which have the kernel and the <a href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html">device
tree blobs</a> already. You need three files from the vendor:</p>

<ul>
  <li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/bootcode.bin">/boot/bootcode.bin</a></li>
  <li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/start.elf">/boot/start.elf</a></li>
  <li><a href="https://github.com/raspberrypi/firmware/raw/master/boot/fixup.dat">/boot/fixup.dat</a></li>
</ul>

<p>So go ahead and download them into your arm64 root’s <em>/boot</em> directory:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

wget https://github.com/raspberrypi/firmware/raw/master/boot/bootcode.bin <span class="nv">$ROOTFS_PATH</span>/boot
wget https://github.com/raspberrypi/firmware/raw/master/boot/start.elf <span class="nv">$ROOTFS_PATH</span>/boot
wget https://github.com/raspberrypi/firmware/raw/master/boot/fixup.dat <span class="nv">$ROOTFS_PATH</span>/boot</code></pre></figure>

<p>Then, you need two configuration files:</p>

<ul>
  <li><a href="https://www.raspberrypi.com/documentation/computers/config_txt.html"><strong>/boot/config.txt</strong></a></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arm_64bit=1
kernel=vmlinuz-6.6.0-rc5-next-20231011
device_tree=/broadcom/bcm2837-rpi-3-b-plus.dtb
</code></pre></div></div>

<ul>
  <li><strong>/boot/cmdline.txt</strong></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root=/dev/mmcblk0p2 rootfstype=ext4 rootwait
</code></pre></div></div>

<h2 id="image-creation">Image Creation</h2>

<p>Now that you have a fully functional root filesystem, it’s time to prepare it to go into
the sd card so that the Pi can finally boot it:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

apt <span class="nb">install </span>dosfstools  <span class="c"># mkfs.vfat</span>

<span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>arm64.img <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>1024

losetup <span class="nt">-fP</span> arm64.img
losetup <span class="nt">-a</span>  <span class="c"># note which /dev/loopN is used, in my case N=0</span>

cfdisk /dev/loop0
<span class="c"># DOS partition scheme:</span>
<span class="c">#   1: 128M, type: b (W95 FAT32), bootable</span>
<span class="c">#   2: ++, type: 83 (Linux)</span>

mkfs.vfat /dev/loop0p1
mkfs.ext4 /dev/loop0p2

<span class="nv">tmp</span><span class="o">=</span><span class="si">$(</span><span class="nb">mktemp</span> <span class="nt">-d</span><span class="si">)</span>
mount /dev/loop0p2 <span class="nv">$tmp</span>
mount /dev/loop0p1 <span class="nv">$tmp</span>/boot

<span class="nb">cp</span> <span class="nt">-a</span> <span class="nv">$ROOTFS_PATH</span>/. <span class="nv">$tmp</span>/.

umount <span class="nv">$tmp</span>/boot
umount <span class="nv">$tmp</span>

<span class="nb">sync

</span>losetup <span class="nt">-d</span> /dev/loop0

<span class="c"># replace &lt;SD_CARD&gt; with the correct value on your system</span>
<span class="nb">dd </span><span class="k">if</span><span class="o">=</span>arm64.img <span class="nv">of</span><span class="o">=</span>/dev/&lt;SD_CARD&gt; <span class="nv">status</span><span class="o">=</span>progress</code></pre></figure>

<h2 id="whats-next">What’s next?</h2>

<p>Well, there are many things to explore if you want to keep tinkering with the kernel
configuration symbols. For example, you could decide to add the <em>/dev/mmcblk0p1</em> boot
partition to your <em>/etc/fstab</em>, but that requires VFAT support:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VFAT_FS              VFAT (Windows-95) fs support
NLS_CODEPAGE_437     Default DOS codepage
NLS_ISO8859_1        ISO/IEC 8859-1 character set
</code></pre></div></div>

<p>Maybe you want to figure out what’s needed for complete networking support, or
learn more about <a href="https://elinux.org/RPi_Low-level_peripherals">GPIO</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Knowing exactly what you’re enabling on the kernel and being able to actually boot it
can give you important insight about the different areas of knowledge that spans this
vast project. You’ll be able to quickly find your way into whatever feature that you
might wanna learn about more. Although a nice exercise, you’re probably better off with
the <a href="https://www.raspberrypi.com/documentation/computers/config_txt.html">vendor configuration</a> as a starting point. There will be many things
there that you’re probably not gonna use, but most of what you need will also be there.
Overall, this is one of the trade-offs distro kernel teams have to deal with.</p>

<p>If you have any question, comment, critic, suggestion or if you spotted an error in
here, please don’t hesitate in reaching out to me at <a href="mailto:ricardo@marliere.net">ricardo@marliere.net</a>.
Good luck and happy hacking!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Funtoo is a Gentoo fork made by Gentoo’s creator, Daniel Robbins. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://developer.arm.com/documentation/ddi0487/latest/">AArch64</a> is the same as ARM64. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>lib/systemd/systemd: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, (…) <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="linux" /><category term="kernel" /><category term="mentorship" /><summary type="html"><![CDATA[In this post, I will go through the steps for building and booting a linux-next kernel on that board you have gathering dust somewhere.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://marliere.net/~ricardo/~ricardo/assets/rpi.png" /><media:content medium="image" url="https://marliere.net/~ricardo/~ricardo/assets/rpi.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">A better workflow for kernel debugging</title><link href="https://marliere.net/~ricardo/2023/10/08/better-workflow.html" rel="alternate" type="text/html" title="A better workflow for kernel debugging" /><published>2023-10-08T15:15:00-03:00</published><updated>2023-10-08T15:15:00-03:00</updated><id>https://marliere.net/~ricardo/2023/10/08/better-workflow</id><content type="html" xml:base="https://marliere.net/~ricardo/2023/10/08/better-workflow.html"><![CDATA[<p>If you followed along my last <a href="/~ricardo/2023/09/06/simple-workflow.html">post</a>, you may have have found some
difficulties like I did. Namely, making sure the work is done without confusion. In this
post I want to share a few tips that helped me stay organized and effective, I hope its
helpful to some of you as well.</p>

<p>When I started investigating bugs I used to have a single <em>git</em> tree and then every time
I wanted to switch bugs or build a stable kernel it was <em>.config</em> hell, a complete mess.
I tried, then, maintaining different local repositories for different trees. But this is
a disk waste. Then I learned about the “<em>make O=</em>” trick to build the objects somewhere
else. It helped but I still had to checkout different commits and keep a tab of what I
was doing in my head. The solution was of course to use <a href="https://git-scm.com/docs/git-worktree">git-worktree</a>.
This is the process (all the variables in this post are illustrative):</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># create your local work directory</span>
<span class="nv">LINUX_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/linux"</span>
<span class="nb">mkdir</span> <span class="nv">$LINUX_DIR</span>
<span class="nb">cd</span> <span class="nv">$LINUX_DIR</span>

<span class="c"># clone a bare repository</span>
git clone <span class="nt">--bare</span> <span class="nt">-o</span> linus git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
<span class="nb">cd </span>linux.git

<span class="c"># add other relevant remotes to you</span>
git remote add shuah git://git.kernel.org/pub/scm/linux/kernel/git/shuah/linux-kselftest.git
git remote add staging git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git
git remote add stable git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git
<span class="c"># (...)</span>

<span class="c"># update all the remotes</span>
git remote update</code></pre></figure>

<p>Now that you have a bare repository, you can add worktrees to split the different
things you might be doing into different directories. Here’s an example:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nb">cd</span> <span class="nv">$LINUX_DIR</span>/linux.git

<span class="c"># add a worktree to track the stable/linux-6.5.y branch</span>
git worktree add <span class="nt">--track</span> <span class="nt">--branch</span> linux-6.5.y ../stable stable/linux-6.5.y

<span class="c"># add a worktree for a syzkaller bug</span>
git worktree add <span class="nt">--checkout</span> ../845cd8e5c47f2a125683 69b41ac87e4a</code></pre></figure>

<p>This way, you can have different directories with different kernel <em>.config</em> files and
different <em>git</em> histories and patches you might be working on. In the example above,
<a href="https://syzkaller.appspot.com/bug?extid=845cd8e5c47f2a125683">845cd8e5c47f2a125683</a> is a random bug I selected and <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?id=69b41ac87e4a664de78a395ff97166f0b2943210">69b41ac87e4a</a>
is the commit ref. from the <em>2023/01/04 06:51</em> row of its crashes. You would proceed by
downloading its <em>.config</em> and other relevant files such as the reproducers. For that
it’s best to have a directory only for these:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nv">BUGS_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/syzkaller-bugs"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$BUGS_DIR</span>/845cd8e5c47f2a125683
<span class="nb">cd</span> <span class="nv">$BUGS_DIR</span>/845cd8e5c47f2a125683

<span class="c"># download relevant files for the bug</span>
<span class="c"># (you might wanna split those into timestamped directories,</span>
<span class="c">#   e.g. $BUGS_DIR/845cd8e5c47f2a125683/202301040651 )</span>
wget <span class="s2">"https://syzkaller.appspot.com/text?tag=KernelConfig&amp;x=9babfdc3dd4772d0"</span> <span class="nt">-O</span> .config
wget <span class="s2">"https://syzkaller.appspot.com/text?tag=ReproC&amp;x=142a1eaa480000"</span> <span class="nt">-O</span> rep.c
wget <span class="s2">"https://storage.googleapis.com/syzbot-assets/d4a7091814ba/bzImage-69b41ac8.xz"</span>
unxz bzImage-69b41ac8.xz

<span class="c"># make your life easier with a link to the worktree</span>
<span class="nb">ln</span> <span class="nt">-s</span> <span class="nv">$LINUX_DIR</span>/845cd8e5c47f2a125683 linux

<span class="nb">cp</span> .config linux/</code></pre></figure>

<p>After the usual building process of the bzImage, its time to jump into a virtual machine
to test your changes. This can also be chaotic and inspired by this great <a href="https://www.linuxfoundation.org/webinars/linux-kernel-debugging-tricks-of-the-trade">mentorship
session</a> done by Joel Fernandes, I wrote some <a href="https://github.com/rbmarliere/rq">scripts</a> to make my life
easier. The main tool is <em>rq</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rq -h

usage: rq [-h] [-I IMG_DIR] [-k KERNEL] [--no-kernel] [-d DISK] [--no-disk]
          [-i INITRD] [-b BIOS] [-p PORT] [-f [F ...]] [-F [F ...]] [-c]
          [-a APPEND] [-g] [--wait-gdb] [--no-snapshot] [--debug]

Run qemu with sane defaults

options:
  -h, --help            show this help message and exit
  -I IMG_DIR, --img-dir IMG_DIR
                        directory containing images (e.g. initramfs, disk,
                        bios), can be set through RQ_IMGDIR environment variable
                        (default: /home/rbmarliere/images)
  -k KERNEL, --kernel KERNEL
                        kernel bootable image to use with -kernel (default:
                        linux/arch/x86/boot/bzImage)
  --no-kernel           do not use -kernel (default: False)
  -d DISK, --disk DISK  disk image to use with -drive (default:
                        /home/rbmarliere/images/disk.img)
  --no-disk             do not use -drive (default: False)
  -i INITRD, --initrd INITRD
                        initrd image to use with -initrd (default: None)
  -b BIOS, --bios BIOS  bios image to use with -bios (default:
                        /home/rbmarliere/images/seabios.bin)
  -p PORT, --port PORT  host's port to forward into guest's ssh port using -net
                        (default: 10022)
  -f [F ...]            file(s) to copy into the disk (default: None)
  -F [F ...]            file(s) to copy into the cpio initrd (default: None)
  -c, --crash           append crashkernel= to cmdline (default: False)
  -a APPEND, --append APPEND
                        append kernel parameters (default: None)
  -g, --gdb             use -s (default: False)
  --wait-gdb            use -S if -s is used (default: False)
  --no-snapshot         do not use -snapshot (default: False)
  --debug               print qemu command instead of running it (default:
                        False)
</code></pre></div></div>

<p>This makes me able to do many things without having to worry about searching back my
shell history for the right <em>qemu</em> command. It’s not perfect, but it helps. If you
noticed, the <em>–bios</em> parameter defaults to <em>/home/rbmarliere/images/seabios.bin</em>, this
is because I’m using a custom built image with a <a href="https://github.com/cirosantilli/linux-kernel-module-cheat/issues/110#issuecomment-1498600775">patch</a> to
<a href="https://gitlab.com/qemu-project/seabios">SeaBIOS</a> that gets rid of the code that truncates long lines in the terminal,
so that I don’t lose precious info from logs. This is what it calls on a default run
without parameters, inside a directory such as <em>$BUGS_DIR/845cd8e5c47f2a125683</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rq --debug

qemu-system-x86_64 \
    -m 8G \
    -smp 2,sockets=2,cores=1 \
    -net nic,model=e1000 \
    -net user,host=10.0.2.25,hostfwd=tcp::10022-:22 \
    -enable-kvm \
    -nographic \
    -bios /home/rbmarliere/images/seabios.bin \
    -snapshot \
    -kernel linux/arch/x86/boot/bzImage \
    -drive format=raw,file=/home/rbmarliere/images/disk.img
</code></pre></div></div>

<p>If you’re feeling courageous and want to give it a try, install them with something like
this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nv">GIT_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/git"</span>

git clone git@github.com:rbmarliere/rq.git <span class="nv">$GIT_DIR</span>/rq

<span class="nb">cd</span> <span class="nv">$HOME</span>/.local/bin
<span class="k">for </span>file <span class="k">in</span> <span class="nv">$GIT_DIR</span>/rq/<span class="k">*</span><span class="p">;</span> <span class="k">do </span><span class="nb">ln</span> <span class="nt">-s</span> <span class="nv">$file</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># add ~/.local/bin to your $PATH, if you don't have it</span>
<span class="nb">echo export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PATH</span><span class="s2">:</span><span class="nv">$HOME</span><span class="s2">/.local/bin"</span> <span class="o">&gt;&gt;</span> ~/.bashrc</code></pre></figure>

<p>Some examples:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nb">export </span><span class="nv">RQ_IMGDIR</span><span class="o">=</span>~/images

<span class="c"># run a specific kernel after copying a reproducer into the disk</span>
rq <span class="nt">-k</span> bzImage-69b41ac8 <span class="nt">-f</span> rep.c

<span class="c"># use an initramfs instead of a disk as the root filesystem</span>
rq <span class="nt">-i</span> initramfs.cpio.gz <span class="nt">-F</span> rep.c <span class="nt">--no-disk</span> <span class="nt">-a</span> <span class="s2">"root=/dev/ram"</span>

<span class="c"># make permanent changes to the disk root filesystem</span>
rq <span class="nt">--no-snapshot</span>

<span class="c"># debug the VM with gdb</span>
rq <span class="nt">-g</span> <span class="nt">--wait-gdb</span></code></pre></figure>

<h2 id="kdump">Kdump</h2>

<p>Recently I was looking into a bug that is a concurrency problem. That means that,
although the reproducer provided can in fact reproduce the problem, it happens at random
times. That means you are probably gonna have to wait for a long time. So as much as the
<em>gdb</em> workflow presented in the <a href="/~ricardo/2023/09/06/simple-workflow.html">last post</a> is very useful, for bugs
like this it can be quite painful. Using <a href="https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html">Kdump</a> and the <a href="https://github.com/crash-utility/crash">crash utility</a> enabled me to inspect the system state at any time without having to depend on a running virtual machine.</p>

<p>I went through this <a href="https://www.youtube.com/watch?v=aUGNDJPpUUg">excellent presentation</a> by Steven Rostedt and I must
say, it took me a while to grasp the process and setup everything. But its a very good
tool to have, sometimes. Hopefully I can help you save some time. The first thing you
need is to build a “crash” kernel. This is the kernel that it’s going to replace the
system kernel after a panic. Here is what I did:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nb">cd</span> <span class="nv">$LINUX_DIR</span>/linux.git

git worktree add <span class="nt">--checkout</span> ../crash v6.5.6
<span class="nb">cd</span> ../crash

make allnoconfig
<span class="c"># from `make help`:</span>
<span class="c"># allnoconfig     - New config where all options are answered with no</span>

make menuconfig
<span class="c"># TIP: when you search for a string using '/' character, the list provided</span>
<span class="c"># have numbers attached to them, which you can use to quickly jump to its</span>
<span class="c"># entry in the menu; you can also use '?' character for help.</span>

<span class="c"># search and enable the following:</span>

<span class="c"># 64BIT               64-bit kernel</span>
<span class="c"># PCI                 support for PCI bus</span>
<span class="c"># ATA                 support for ATA hard disk used in -disk parameter</span>
<span class="c"># ATA_PIIX            ATA controller emulated by the default qemu x86_64 machine</span>
<span class="c"># SERIAL_8250         support for serial ports</span>
<span class="c"># SERIAL_8250_CONSOLE this enables the virtual machine console to be readable</span>

<span class="c"># EXT4_FS             the filesystem used before, when creating the root fs</span>
<span class="c"># BLK_DEV_SD          this makes /dev/sda visible</span>

<span class="c"># NET                 we want networking inside the VM</span>
<span class="c"># NETDEVICES          add support for networking devices</span>
<span class="c"># E1000               driver for the -net nic,model=e1000 parameter</span>

<span class="c"># INET                TCP/IP support</span>
<span class="c"># UNIX                Unix sockets support, e.g. for /var/log/* and system utils</span>
<span class="c"># PACKET              Packet protocol</span>

<span class="c"># BINFMT_ELF          enables kernel to execute ELF files</span>
<span class="c"># BINFMT_SCRIPT       enables kernel to execute '#!' scripts</span>
<span class="c"># DEVTMPFS            create a /dev early on, to support early API filesystems</span>
<span class="c"># DEVTMPFS_MOUNT      auto mount /dev</span>
<span class="c"># TMPFS               support early API filesystems</span>

<span class="c"># CRASH_DUMP          Kdump requirement</span>
<span class="c"># RELOCATABLE         Kdump requirement</span>

<span class="c"># CGROUPS             * (systemd requirement)</span>
<span class="c"># INOTIFY_USER        * (systemd requirement)</span>
<span class="c"># DEBUG_FS            *</span>
<span class="c"># SECURITYFS          *</span>
<span class="c"># CONFIGFS_FS         *</span>
<span class="c"># BINFMT_MISC         *</span>
<span class="c"># AUTOFS_FS           * (for proc-sys-fs-binfmt_misc.automount service)</span>

make bzImage</code></pre></figure>

<p>This was the first time I configured a minimal kernel from zero and I learned a lot from
it. These are the symbols that need to be enabled to successfully boot the kernel after
a crash. Note that the ones marked with <strong>*</strong> are dependencies for the root filesystem.
Systemd needs CGROUPS and INOTIFY_USER and the others come from the <em>/etc/fstab</em> written
by the syzkaller’s <a href="https://github.com/google/syzkaller/blob/master/tools/create-image.sh#L161">create-image.sh</a> script that I used to create my
root filesystem (therefore, optional).</p>

<p>After this, you should install <em>kdump-tools</em> inside your VM:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># you can use any kernel to boot the VM, e.g.</span>
<span class="nb">cd</span> <span class="nv">$BUGS_DIR</span>/845cd8e5c47f2a125683
rq <span class="nt">--no-snapshot</span> <span class="nt">-k</span> bzImage-69b41ac8

<span class="c"># after booting, inside the VM</span>
apt <span class="nb">install </span>kdump-tools
vi /etc/default/kdump-tools</code></pre></figure>

<p>Edit the <em>/etc/default/kdump-tools</em> file, inside the VM, accordingly (remember to use
<em>--no-snapshot</em> to make it permanent). Please refer to Debian’s documentation on
kdump-tools in <a href="https://salsa.debian.org/debian/kdump-tools/-/blob/master/debian/kdump-tools.README.Debian">/usr/share/doc/kdump-tools/README.Debian</a>. Here is mine:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>USE_KDUMP=1
KDUMP_COREDIR="/var/crash"
SSH="rbmarliere@10.0.2.25"
SSH_KEY="/root/.ssh/id_rsa"
</code></pre></div></div>

<p>This way, whenever a crash happens, the <em>kdump-tools</em> will transfer the dump file into my
host’s <em>/var/crash/</em> directory. Before, I did the usual <em>ssh</em> authorization process of
creating a <em>ssh</em> key with <a href="https://man.openbsd.org/ssh-keygen.1"><em>ssh-keygen</em></a> in the host, transferring the private
id_rsa into the VM and pasting the public key into the host’s <em>~/.ssh/authorized_keys</em>.
Also, make sure <em>/var/crash</em> is owned and writable by your user in the host, or change
<em>KDUMP_COREDIR</em> to something else.</p>

<p>Now we are only missing three things:</p>

<ul>
  <li>Boot the system kernel with <em>crashkernel=</em> cmdline;</li>
  <li>Load the crash kernel into memory using <em>kexec</em>;</li>
  <li>Trigger the crash;</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># make your life easier with a link to the crashkernel</span>
<span class="nb">cd</span> <span class="nv">$BUGS_DIR</span>/
<span class="nb">ln</span> <span class="nt">-s</span> <span class="nv">$LINUX_DIR</span>/crash/arch/x86_64/boot/bzImage crashkernel

<span class="c"># copy the crashkernel into the root filesystem next time you boot a VM</span>
<span class="c"># -f copies the file into /root/ by default</span>
<span class="c"># -c will append crashkernel=256M to the boot cmdline</span>
<span class="nb">cd</span> <span class="nv">$BUGS_DIR</span>/845cd8e5c47f2a125683
rq <span class="nt">-c</span> <span class="nt">-f</span> ../crashkernel

<span class="c"># after boot, inside the VM</span>
kexec <span class="nt">-p</span> /root/crashkernel <span class="nt">--append</span><span class="o">=</span><span class="s2">"console=ttyS0 root=/dev/sda"</span>

<span class="c"># trigger the crash with CONFIG_MAGIC_SYSRQ=y</span>
<span class="nb">echo </span>c <span class="o">&gt;</span> /proc/sysrq-trigger

<span class="c"># ...or run a syz reproducer</span>
gcc rep.c <span class="o">&amp;&amp;</span> ./a.out</code></pre></figure>

<p>Note the need for <em>root=/dev/sda</em> for the automatic handling of the crash dump taking
place. If all went well, you’re gonna see the dump and the dmesg files under your host
<em>/var/crash</em> directory. But how to use it? Here enters the <a href="https://github.com/crash-utility/crash">crash utility</a>. For
some reason that I didn’t fully understand – probably Debian related<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> – I was only able
to inspect the dump file using a locally built binary. Therefore, don’t install the
<a href="https://tracker.debian.org/pkg/crash">crash</a> package in your host.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="nv">$GIT_DIR</span>/crash/crash <span class="nv">$LINUX_DIR</span>/845cd8e5c47f2a125683/vmlinux dump.202310081631</code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crash 8.0.3
Copyright (C) 2002-2022  Red Hat, Inc.
Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation
Copyright (C) 1999-2006  Hewlett-Packard Co
Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited
Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.
Copyright (C) 2005, 2011, 2020-2022  NEC Corporation
Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.
Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.
Copyright (C) 2015, 2021  VMware, Inc.
This program is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it under
certain conditions.  Enter "help copying" to see the conditions.
This program has absolutely no warranty.  Enter "help warranty" for details.

GNU gdb (GDB) 10.2
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-pc-linux-gnu".
Type "show configuration" for configuration details.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...

please wait... (determining panic task)
WARNING: active task ffff888102323780 on cpu 1 not found in PID hash

      KERNEL: /mnt/md0/linux/845cd8e5c47f2a125683/vmlinux
    DUMPFILE: dump.202310081631  [PARTIAL DUMP]
        CPUS: 2
        DATE: Sun Oct  8 13:31:48 -03 2023
      UPTIME: 00:01:22
LOAD AVERAGE: 0.95, 0.47, 0.17
       TASKS: 3
    NODENAME: syzkaller
     RELEASE: v6.2-rc3~30
     VERSION: #7 SMP PREEMPT_DYNAMIC Sun Oct  8 10:34:01 -03 2023
     MACHINE: x86_64  (3892 Mhz)
      MEMORY: 8 GB
       PANIC: "Kernel panic - not syncing: sysrq triggered crash"
         PID: 4194
     COMMAND: "bash"
        TASK: ffff888102323780  [THREAD_INFO: ffff888102323780]
         CPU: 1
       STATE: TASK_RUNNING (PANIC)

crash&gt; bt
PID: 4194     TASK: ffff888102323780  CPU: 1    COMMAND: "bash"
 #0 [ffffc9000166f968] machine_kexec at ffffffffb0728db3
 #1 [ffffc9000166fa58] __crash_kexec at ffffffffb0a417a6
 #2 [ffffc9000166fbb8] panic at ffffffffb077eedd
 #3 [ffffc9000166fca0] sysrq_handle_crash at ffffffffb1e3228c
 #4 [ffffc9000166fcb0] __handle_sysrq at ffffffffb1e334e0
 #5 [ffffc9000166fcf8] write_sysrq_trigger at ffffffffb1e34ea4
 #6 [ffffc9000166fd18] proc_reg_write at ffffffffb122c99c
 #7 [ffffc9000166fd58] vfs_write at ffffffffb10324d4
 #8 [ffffc9000166fda8] vfs_fstatat at ffffffffb104cac2
 #9 [ffffc9000166fde0] __do_sys_newfstatat at ffffffffb104d252
#10 [ffffc9000166ff38] do_syscall_64 at ffffffffb5aab7c9
#11 [ffffc9000166ff50] entry_SYSCALL_64_after_hwframe at ffffffffb5c0008b
    RIP: 00007fb4c359cb00  RSP: 00007fff42199c08  RFLAGS: 00000202
    RAX: ffffffffffffffda  RBX: 0000000000000002  RCX: 00007fb4c359cb00
    RDX: 0000000000000002  RSI: 00005645a39eeaa0  RDI: 0000000000000001
    RBP: 00005645a39eeaa0   R8: 0000000000000400   R9: 0000000000000410
    R10: 0000000000000000  R11: 0000000000000202  R12: 0000000000000002
    R13: 00007fb4c3679780  R14: 0000000000000002  R15: 00007fb4c3674d00
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b
crash&gt; info threads
  Id   Target Id         Frame
* 1    CPU 0             &lt;unavailable&gt; in ?? ()
  2    CPU 1             &lt;unavailable&gt; in ?? ()
crash&gt; panic
panic = $1 =
 {void (const char *, ...)} 0xffffffffb077e9b0 &lt;panic&gt;
crash&gt; ps
      PID    PPID  CPU       TASK        ST  %MEM      VSZ      RSS  COMM
&gt;       0       0   0  ffffffffb722b800  RU   0.0        0        0  [swapper/0]
        0       0   1  ffff888102e61bc0  RU   0.0        0        0  [swapper/1]
&gt;    4194      -1   1  ffff888102323780  RU   0.0     4772     3924  bash
</code></pre></div></div>
<p>— <em>Note that you should have DEBUG_INFO enabled on the system kernel that crashed!</em></p>

<h2 id="general-tips">General tips</h2>

<p>I use this as my <em>/root/.bash_profile</em> inside the VM:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># fix the row/col height of the terminal</span>
<span class="nb">stty </span>rows 71 cols 113

<span class="c"># auto build whatever rep.c copied into /root/ using `rq -f`</span>
<span class="o">[</span> <span class="nt">-f</span> ~/rep.c <span class="o">]</span> <span class="o">&amp;&amp;</span> gcc ~/rep.c

<span class="c"># make your life easier with some aliases</span>
<span class="nb">alias </span><span class="nv">a</span><span class="o">=</span><span class="s2">"./a.out"</span>
<span class="nb">alias </span><span class="nv">s</span><span class="o">=</span><span class="s2">"./syz-execprog syz"</span>
<span class="nb">alias </span><span class="nv">kex</span><span class="o">=</span><span class="s2">"kexec -p crashkernel --append='console=ttyS0 root=/dev/sda'"</span></code></pre></figure>

<p>Also this <em>~/.ssh/config</em> in my host system to quickly <em>ssh</em> or <em>scp</em> into the VM:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host syz
	Hostname localhost
	User root
	NoHostAuthenticationForLocalhost yes
	IdentityFile ~/images/syzkaller.id_rsa
	Port 10022
</code></pre></div></div>

<p>In my host <em>~/.bashrc</em>, I use these:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">LINUX_DIR</span><span class="o">=</span>~/linux

<span class="c"># function to get maintainer for a patch from anywhere</span>
get_maintainer<span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
		</span><span class="nb">echo</span> <span class="s2">"usage: get_maintainer &lt;patch&gt;"</span>
		<span class="k">return
	fi
	</span><span class="nv">patch</span><span class="o">=</span><span class="si">$(</span><span class="nb">realpath</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
	<span class="nb">pushd</span> <span class="nv">$LINUX_DIR</span>/linus <span class="o">&gt;</span> /dev/null  <span class="c"># assumes a 'linus' worktree there</span>
	scripts/get_maintainer.pl <span class="s2">"</span><span class="nv">$patch</span><span class="s2">"</span>
	<span class="nb">popd</span> <span class="o">&gt;</span> /dev/null
<span class="o">}</span>

<span class="c"># enables the use of `cd bugs` from anywhere</span>
<span class="nb">shopt</span> <span class="nt">-s</span> cdable_vars
<span class="nv">bugs</span><span class="o">=</span>~/syzkaller-bugs

<span class="c"># a few useful aliases</span>
<span class="nb">alias </span><span class="nv">cdL</span><span class="o">=</span><span class="s2">"cd </span><span class="nv">$LINUX_DIR</span><span class="s2">/linux/linux.git"</span>
<span class="nb">alias </span><span class="nv">cdl</span><span class="o">=</span><span class="s2">"cd </span><span class="nv">$LINUX_DIR</span><span class="s2">/linux"</span>
<span class="nb">alias </span><span class="nv">checkpatch</span><span class="o">=</span><span class="s2">"</span><span class="nv">$LINUX_DIR</span><span class="s2">/linus/scripts/checkpatch.pl"</span>
<span class="nb">alias </span><span class="nv">db</span><span class="o">=</span><span class="s2">"gdb -tui -ex 'target remote :1234' -d linux"</span>
<span class="nb">alias </span><span class="nv">make</span><span class="o">=</span><span class="s1">'make -j$(nproc)'</span></code></pre></figure>

<p>I hope I provided some inspiration to improve your workflow if you are a kernel hacker
wannabe like myself. If you have any question, comment, critic, suggestion or if you
spotted an error in here, please don’t hesitate in reaching out to me at
<a href="mailto:ricardo@marliere.net"><em>ricardo@marliere.net</em></a>.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>As far as I can tell, <em>kdump-tools</em> is packaged with the clear use case of dumping a running Debian kernel and depends on the distro <em>/boot/*</em> files <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="linux" /><category term="kernel" /><category term="mentorship" /><summary type="html"><![CDATA[If you followed along my last post, you may have have found some difficulties like I did. Namely, making sure the work is done without confusion. In this post I want to share a few tips that helped me stay organized and effective, I hope its helpful to some of you as well.]]></summary></entry><entry><title type="html">A simple workflow to debug the Linux Kernel</title><link href="https://marliere.net/~ricardo/2023/09/06/simple-workflow.html" rel="alternate" type="text/html" title="A simple workflow to debug the Linux Kernel" /><published>2023-09-06T15:45:00-03:00</published><updated>2023-09-06T15:45:00-03:00</updated><id>https://marliere.net/~ricardo/2023/09/06/simple-workflow</id><content type="html" xml:base="https://marliere.net/~ricardo/2023/09/06/simple-workflow.html"><![CDATA[<p>Hello again!</p>

<p>I’m happy to announce that I have been accepted as a mentee for the 2023 Fall edition of
the <a href="https://mentorship.lfx.linuxfoundation.org/project/65d4c337-66fd-4d22-8a21-e836fafbebc4">“Linux Kernel Bug Fixing”</a> mentorship from the Linux Foundation.
Writing about the experience is one of the required tasks and that is indeed the
motivation behind the creation of this blog, although I flirted with the idea before but
never got to actually publish anything. Since the main task of the mentorship is to fix
bugs, I’m gonna try to organize my thoughts about the workflow for accomplishing that in
this post. The basic assumption is of course x86_64, for the sake of simplicity.</p>

<p>The Linux Kernel is a vast project that spans many areas of computing and long are the
days where a single mind could understand it all as a whole. The majority of the work in
it is done by big companies that need to support it for their operation. It can be
overwhelming to even try finding a <a href="https://www.kernel.org/doc/html/latest/process/development-process.html">place where to start</a> and this is why intern and
mentorship programs are so important! It is typical for first time contributors to any FOSS
project to focus on QA - Quality Assurance. That could mean many things but in the
context of the Linux Kernel, fixing bugs is the best example. In other projects, simply
using it extensively and reporting a bug found is already a great contribution, but for
simple desktop users such as myself it is rather difficult to come across a bug in the
kernel, these days.</p>

<p>This is where automated tools such as <a href="https://github.com/google/syzkaller/">Syzkaller</a> can come in handy. It is a
fuzzer and nowadays it supports all other major kernels. Software fuzzing is a technique
that feeds random inputs into a program until it crashes and it can be done with pretty
much any program that takes input somehow. In the context of the Linux Kernel, that can
get quite complicated, but it is not the scope of this text to go much into these
details. Please refer to <a href="https://www.linuxfoundation.org/webinars/dynamic-program-analysis-for-fun-and-profit">this excellent presentation</a> by one of the original
developer of the tool, Dmitry Vyukov. For the purpose of this text it is sufficient to
say that there is <a href="https://syzkaller.appspot.com/">infrastructure</a> setup that extensively test the kernel in
many <a href="https://syzkaller.appspot.com/upstream/repos">trees</a> and architectures, so that bugs get reported to the mailing
lists as they’re found.</p>

<p>There are many other tools available for testing and finding bugs in the kernel, of
which Sergio Prado wrote a <a href="https://sergioprado.blog/how-is-the-linux-kernel-tested/">nice summary</a> about. But the goal here is to focus
on the <em>fixing</em> part of the process. For that I must refer the reader to <a href="https://lwn.net/images/pdf/LDD3/ch04.pdf">Chapter
4</a> of the classic book “Linux Device Drivers”. It is also a good idea to read the
available documentation of the kernel on the subject, such as <a href="https://www.kernel.org/doc/html/latest/dev-tools/kgdb.html">this</a>.
Another technique which is essential to the task is tracing, which was masterfully
introduced in <a href="https://www.youtube.com/watch?v=JRyrhsx-L5Y">this talk</a> by Steven Rostedt.</p>

<p>Another <a href="https://www.linuxfoundation.org/webinars/tools-and-techniques-to-debug-an-embedded-linux-system">great introduction</a> on debugging tools and techniques was made by
Sergio Prado. In it, he starts by splitting the most common problems in 5 categories,
namely:</p>
<ul>
  <li>Crash</li>
  <li>Lockup / Hang</li>
  <li>Logic / Implementation</li>
  <li>Resource Leakage</li>
  <li>Performance</li>
</ul>

<p>Each one of these require a different set of skills and strategies, which include log
and dump analysis, tracing and profiling, interactive debugging, etc. The basic workflow
to fix a bug is comprised of a few high level steps:</p>
<ul>
  <li>Find the bug</li>
  <li>Reproduce it</li>
  <li>Identify the cause</li>
  <li>Develop the fix</li>
  <li>Test that it worked</li>
</ul>

<p>For each of these steps there are several sub-steps, depending on the degree of
complexity of the problem. For simplicity, let’s illustrate what a common crash analysis
reported by Syzkaller would look like. First, go to its dashboard and find a bug you
might be interested on. Make sure to read <a href="https://github.com/google/syzkaller/blob/master/docs/linux/">their documentation</a> before
that. You gonna need to know the basics of a kernel <em>oops</em>, too. Refer to <a href="https://www.opensourceforu.com/2011/01/understanding-a-kernel-oops/">here</a>
as a good starting point.</p>

<p>After finding the bug, you must be able to reproduce it. Many of the bugs reported have
C programs carefully crafted by the tool that will trigger the issue. There are also a
special <em>syz</em> program, but we’ll get into that later. For each bug, the syzbot also
supply us with the kernel <em>.config</em> file and the specific commit which triggers the issue.
That is, if you run the C reproducer on any other kernel version, or any other
configuration, the problem may not arise. So, if you want to be able to successfully
reproduce it, you must take that into account. The bot also provides a bootable
QEMU-enabled disk image and the kernel <em>vmlinux</em> and <em>bzImage</em> for your convenience (more on
that <a href="https://github.com/google/syzkaller/blob/master/docs/syzbot_assets.md">here</a>). That is excellent for rapid testing, however if you are to
locally test a patch you’re developing, you gonna need to build it anyway.</p>

<p>Alright, so the goal is to reproduce the error in a QEMU virtual machine with a locally
built <em>bzImage</em>. But first things first. A kernel image by itself isn’t of much use
without a root filesystem from where you can run a reproducer program. I recommend at
least once going through the process of <a href="https://ibug.io/blog/2019/04/os-lab-1/">manually creating</a> an initramfs to boot
into, after reading about it in the <a href="https://www.kernel.org/doc/html/latest/filesystems/ramfs-rootfs-initramfs.html">kernel documentation</a>. Luckily, there
are many tools to accomplish that automatically, such as <a href="https://buildroot.org/">Buildroot</a> - which
is extra useful if you’re hacking around with embedded devices and cross-compilation.
But since the context here is Syzkaller, let’s use <a href="https://github.com/google/syzkaller/blob/master/tools/create-image.sh">their script</a>, so download
it somewhere into your system. It is an automated tool to create a suitable image to use
with QEMU. It leverages Debian’s <a href="https://wiki.debian.org/Debootstrap">Debootstrap</a> tool, so if you’re not
running Debian this is another reason to :)</p>

<p>Create a trixie (current Debian’s <a href="https://wiki.debian.org/DebianReleases"><em>testing</em> distribution</a>) image like so
(make sure you have the required dependencies installed):</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
wget <span class="s2">"https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh"</span>
<span class="nb">chmod</span> +x create-image.sh
./create-image.sh <span class="nt">--distribution</span> trixie</code></pre></figure>

<p>This yields three files: <em>trixie.img</em>, <em>trixie.id_rsa</em> and <em>trixie.id_rsa.pub</em>, which
we’ll use shortly. Now that we have the root filesystem, we need to build the kernel.
Let’s take a look at <a href="https://groups.google.com/g/syzkaller-bugs/c/YIWmpQWCjT4/m/tw1tfm_xBAAJ">this bug</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello,

syzbot found the following issue on:

HEAD commit: b84acc11b1c9 Merge tag 'fbdev-for-6.6-rc1' of git://git.ke..
git tree: upstream
console+strace: https://syzkaller.appspot.com/x/log.txt?x=10e9af87a80000
kernel config: https://syzkaller.appspot.com/x/.config?x=3aba740d8a88ff1d
dashboard link: https://syzkaller.appspot.com/bug?extid=c063a4e176681d2e0380
compiler: gcc (Debian 12.2.0-14) 12.2.0, GNU ld (GNU Binutils for Debian) 2.40
syz repro: https://syzkaller.appspot.com/x/repro.syz?x=16e4acdba80000
C reproducer: https://syzkaller.appspot.com/x/repro.c?x=14eb56dba80000

Downloadable assets:
disk image: https://storage.googleapis.com/syzbot-assets/8b5634407855/disk-b84acc11.raw.xz
vmlinux: https://storage.googleapis.com/syzbot-assets/31f561af0e06/vmlinux-b84acc11.xz
kernel image: https://storage.googleapis.com/syzbot-assets/37275212826f/bzImage-b84acc11.xz

IMPORTANT: if you fix the issue, please add the following tag to the commit:
Reported-by: syzbot+c063a4...@syzkaller.appspotmail.com

(...)
</code></pre></div></div>

<p>Note however that these resources are only available until the bugs are fixed, so if you
can’t download these files at the time of reading just proceed to investigate a more
recent bug.</p>

<p>Let’s build the kernel, so if you haven’t already this is the time to clone Linus’ tree:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
<span class="nb">cd </span>linux
git checkout b84acc11b1c9
wget <span class="s2">"https://syzkaller.appspot.com/x/.config?x=3aba740d8a88ff1d"</span> <span class="nt">-O</span> .config
make menuconfig
<span class="c"># Kernel hacking</span>
<span class="c">#   -&gt; Generic Kernel Debugging Instruments</span>
<span class="c">#     -&gt; KGDB: kernel debugger</span>
<span class="c">#        y</span>
make bzImage</code></pre></figure>

<p>As you see, we checked out the same commit that syzbot used, under the same tree. We
also used the same <em>.config</em> file to build the <em>bzImage</em>. Note that the assumption here is
that your host is running Debian as well, which is the same system as the bot. In some
builds it uses clang so the appropriated <em>CC=clang</em> flag should be used. Also, you could
add a few debugging configurations to the kernel, since we’ll be using that <em>bzImage</em> to
debug and investigate the root cause of the reported bug.</p>

<p>Now that we have the <em>bzImage</em>, let’s use it to boot the <em>trixie.img</em> rootfs:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="nv">ROOTFS</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/trixie.img"</span>
<span class="nv">BZIMAGE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/linux/arch/x86/boot/bzImage"</span>
qemu-system-x86_64 <span class="se">\</span>
	<span class="nt">-m</span> 2G <span class="se">\</span>
	<span class="nt">-smp</span> 2,sockets<span class="o">=</span>2,cores<span class="o">=</span>1 <span class="se">\</span>
	<span class="nt">-net</span> nic,model<span class="o">=</span>e1000 <span class="se">\</span>
	<span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.25,hostfwd<span class="o">=</span>tcp::10022-:22 <span class="se">\</span>
	<span class="nt">-enable-kvm</span> <span class="se">\</span>
	<span class="nt">-nographic</span> <span class="se">\</span>
	<span class="nt">-machine</span> pc-q35-7.1 <span class="se">\</span>
	<span class="nt">-snapshot</span> <span class="se">\</span>
	<span class="nt">-append</span> <span class="s2">"root=/dev/sda console=ttyS0 earlyprintk=serial net.ifnames=0"</span> <span class="se">\</span>
	<span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span><span class="s2">"</span><span class="nv">$ROOTFS</span><span class="s2">"</span> <span class="se">\</span>
	<span class="nt">-kernel</span> <span class="s2">"</span><span class="nv">$BZIMAGE</span><span class="s2">"</span></code></pre></figure>

<p>This QEMU command will spawn a x86_64 virtual machine (of type pc-q35-7.1,
<em>qemu-system-x86_64 -machine help</em> for more options) and boot your kernel into the
trixie rootfs, make sure to point to the correct paths in the <em>$ROOTFS</em> and <em>$BZIMAGE</em>
variables. This command is given as a reference in the Syzkaller’s
<a href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md#crash-does-not-reproduce">documentation</a>, however you should take a look at QEMU’s <a href="https://qemu-project.gitlab.io/qemu/index.html">manual
pages</a> if you haven’t yet. You can see we passed both the kernel image and the
rootfs disk as parameters, and since the <em>create-image.sh</em> script also take care of
setting up networking and a SSH server for us (that’s why it also yields <em>trixie.id_rsa</em>
and <em>trixie.id_rsa.pub</em>), the command will spawn a network interface with your local
host 10022 port being forwarded into its 22 port through the <em>-net</em> argument. That means
you can log into the guest system and transfer files through the ssh protocol using
<em>localhost:10022</em>.</p>

<p>Another important parameter is <em>-snapshot</em>. Using it means that whatever modification
you do to the rootfs won’t be persisted through reboots. So if you transfer a file into
it and halt the system, it won’t be there when you start a machine again with it. That
makes possible for many guests running in parallel using the same rootfs. You could also
remove this argument for one time in order to make changes such as changing the root
password or installing a dependency. For example, if you want to reproduce bugs using
the <em>syz</em> program reproducer you’re gonna need to build syzkaller locally and transfer
the <em>bin/linux_amd64/syz-executor</em> and <em>bin/linux_amd64/syz-execprog</em> files into the rootfs,
so you can transfer these files just once, without having to redo this step every time
you boot a kernel.</p>

<p>So now that the machine is running, you can go ahead and reproduce the bug in it. First,
download the reproducer program, then transfer it into the rootfs and finally log into
it through ssh (note that you could do this from inside the rootfs, by ssh’ing first):</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
wget <span class="s2">"https://syzkaller.appspot.com/x/repro.c?x=14eb56dba80000"</span> <span class="nt">-O</span> reproducer.c
<span class="nv">IDENTITY</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/trixie.img.id_rsa"</span>
scp <span class="nt">-i</span> <span class="s2">"</span><span class="nv">$IDENTITY</span><span class="s2">"</span> <span class="nt">-P</span> 10022 reproducer.c root@localhost:~/
ssh <span class="nt">-i</span> <span class="s2">"</span><span class="nv">$IDENTITY</span><span class="s2">"</span> <span class="nt">-p</span> 10022 root@localhost</code></pre></figure>

<p>Now, inside the virtual machine simply build the program and run it:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
gcc <span class="nt">-Wall</span> reproducer.c <span class="nt">-o</span> reproducer
./reproducer</code></pre></figure>

<p>To make things easier, I always like to add aliases to my <em>~/.bashrc</em> whenever possible.
They allow me to quickly go through the work without having to deal with the shell
history or copy/pasting. Consider these:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="nb">alias </span>qemu-<span class="o">=</span><span class="s1">'qemu-system-x86_64 -m 2G -smp 2,sockets=2,cores=1 -net nic,model=e1000 -net user,host=10.0.2.25,hostfwd=tcp::10022-:22 -enable-kvm -nographic -machine pc-q35-7.1 -append "root=/dev/sda console=ttyS0 earlyprintk=serial net.ifnames=0" -snapshot -drive format=raw,file=/home/rbmarliere/images/syzkaller/trixie.img -kernel'</span>
<span class="nb">alias </span>ssh-<span class="o">=</span><span class="s1">'ssh -i /home/rbmarliere/images/syzkaller/trixie.id_rsa -p 10022 root@localhost'</span>
<span class="nb">alias </span>scp-<span class="o">=</span><span class="s1">'scp -i /home/rbmarliere/images/syzkaller/trixie.id_rsa -P 10022 '</span></code></pre></figure>

<p>Lastly, to be able to really debug and step through the code with <a href="https://www.sourceware.org/gdb/documentation/"><em>gdb</em></a> you
can use the <em>-s</em> argument to the QEMU command. That’s when a <em>vmlinux</em> image with
debugging information is useful. Could be the one you downloaded from the syzbot bug
report or the one you built before (if you enabled KGDB as suggested, you’re gonna be
better equipped than using the image that syzbot provided). Start the virtual machine
like before , appending the <em>-s</em> argument. Then, start <em>gdb</em> passing the <em>vmlinux</em> as
argument:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="nv">VMLINUX</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/linux/vmlinux"</span>
gdb <span class="nt">-tui</span> <span class="s2">"</span><span class="nv">$VMLINUX</span><span class="s2">"</span>

<span class="c"># then, inside gdb shell:</span>
target remote :1234</code></pre></figure>

<p>To illustrate, below are two screenshots of this setup. It’s from a different bug than
the one mentioned in this post, but it doesn’t matter. I set a breakpoint at the <em>panic</em>
kernel function and then ran the reproducer:</p>

<p><img src="/~ricardo/assets/gdb_setup.png" alt="gdb" />
— <em>Here you can see the virtual machine’s console in the left, right before executing the
reproducer, and the host’s gdb tui in the right.</em></p>

<p><img src="/~ricardo/assets/gdb_panic.png" alt="gdb" />
— <em>After executing the reproducer, the execution stops at the breakpoint we set
before, at the panic() function in the kernel/panic.c file.</em></p>

<p>After working your way to tackle the problem, you can apply a patch to your local tree,
rebuild the kernel images and re-test with the reproducer until you get it right. Make
sure to see if the problem wasn’t already fixed by someone else before sending the patch
upstream, though. Anyway, we didn’t even scratch the surface here, but I hope this sheds
light into basic debugging techniques and make you better equipped to explore your way
into the kernel internals!</p>]]></content><author><name></name></author><category term="linux" /><category term="kernel" /><category term="mentorship" /><summary type="html"><![CDATA[Hello again!]]></summary></entry><entry><title type="html">Hello World</title><link href="https://marliere.net/~ricardo/about" rel="alternate" type="text/html" title="Hello World" /><published>2023-09-05T21:21:39-03:00</published><updated>2023-09-05T21:21:39-03:00</updated><id>https://marliere.net/~ricardo/hello-world</id><content type="html" xml:base="https://marliere.net/~ricardo/about"><![CDATA[<p>Greetings,</p>

<p>For this first post I thought it would be best if I introduced myself. My name is
Ricardo and I was born in Brazil in July of the year 1991. When I’m not at my desk
studying about computers and technology or occasionally gaming, I like to <a href="https://pathos.band/">play
guitar</a> and write songs. I have a small vinyl <a href="https://www.discogs.com/user/rbmarliere/collection">collection</a> and own a
few vintage out of print esoteric books. On some weekends, if I’m lucky, I’ll be
crossing the finish line in a racing car at a track somewhere. But more commonly I’ll be
offline enjoying the company of my beautiful wife. I’m also a private pilot currently
pursuing my IFR license. As you see, I’ve been dedicating my time across many interests,
but my goal here is mostly to write about software, at least initially.</p>

<p>I’m about just as much as old as the Linux project itself, and I was about 10 years old
when I first learned that computers could be used for more than playing games, at a time
when Brazilian internet providers were booming. By then, my older brother was already
hacking around and he got me into mIRC Scripting. Maybe an odd choice for a first
programming language, but I was determined to do what any kid would probably think about
doing: create my own game, of course :). That natural curiosity and stubbornness was
responsible for leading me down a path of experimental learning, which helped me create
the solid foundation where I stand today. We truly stand on the shoulders of giants when
it comes to software. Anyhow, I still remember the feeling of awe I had when my brother
first brought home a Mandrake Linux CD-ROM. One of the first things I noted was that the
mouse cursor was black! That was cool. Many years later, there I was at the university
studying with classmates getting to know about programming for the first time. It felt
weird, because it was so natural to me.</p>

<p>After the mIRC days came the Linux exploring nights, trying to learn as much as I could
out of the shell and the old C books my father had laying around. The major problem I
had though, is that I also had to learn English. It was rather confusing but eventually
I reached a ‘good enough’ point. I remember the first time I felt that I was actually
having some better understanding was when I accepted the challenge of installing the
recently launched Slackware 12. A few weeks later I would run <em>make menuconfig</em> on the
2.6 kernel for the first time. Suffice to say that I wasn’t able to boot it. So begins
my distro hopping days. I learned a lot those days, but I had a common teenager problem:
focus. I wanted to do everything. I still do, but as you get older you learn to optimize
your time and energy, while knowing yourself a bit more to define priorities more
easily. But then, I decided that programming wasn’t for me and I got distracted with a
million things. Mostly gaming and music.</p>

<p>When I joined the university I wasn’t sure if I would pursue a Math, Physics or
Computing degree. I flirted with those other areas only to be confronted with the harsh
reality that I was pretty bad at it. My natural aptitude put me back on track to
programming. I also was able to get my first job as a PHP web developer, after a year or
so as a research mentee. In the 3.x kernel days my main driver was Linux Mint. At least
until I bought a Macbook and decided to get my feet wet with audio engineering. I don’t
regret it, but that has set me back another year or so.</p>

<p>After getting tired of the Apple jail and a brief period of FreeBSD and Arch Linux,
struggling to keep the system stable, I decided to give Gentoo and later Funtoo a spin
with the 4.x kernels. I used that extensively for years. That’s when I first read about
the development process within the Linux project. I also went through the first levels
of the <a href="http://eudyptula-challenge.org/">Eudyptula Challenge</a> and the <a href="https://io.netgarage.org/">IO wargame</a>, which got me very
excited after spending so much time in the web development maze.</p>

<p>I’m happy to say that my distro hopping days are over though and Debian is my weapon of
choice. I regret not taking the time earlier to read more about the project and its
organization, but everything I did turned out to be exactly what I needed to learn at
the time. As the old saying goes, all roads lead to Rome. In any case, I was busy in the
last few years studying cryptocurrencies and finance in general, while hacking around
with a lot of Python in between.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Greetings,]]></summary></entry></feed>